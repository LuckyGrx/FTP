1. 服务器端接收文件的正确性？
     - 问题：

          - 字节流文件无法通过查看内容或者简单的查看文件字节数验证正确性

     - 解决办法：

          - 使用md5sum验证

2. 为了提高并发性而产生的错误？
     - 问题：

          - 为了提高并发性，将任务处理函数放置在互斥锁外执行时，会存在文件传输错误的情况

     - 原因：

          - 当某个工作（worker）线程在执行任务处理函数里的IO操作时，要是该任务绑定的已连接描述符有新的数据达到，会触发其他工作（worker）线程去处理该这些数据，导致两个worker线程同时修改同一个结构体的情况

     - 解决办法:

          - 添加EPOLLONESHOT模式，强制只读一次至读到EAGAIN为止，并epoll_mod该可读事件

3. 线程池的实现？
     - 使用互斥锁保证对线程池的互斥访问，使用条件变量实现同步

     - 初始化线程池，创建工作（worker）线程

     - 各线程入口函数最外层为while循环，获得互斥锁的线程进入线程池，若任务（task）队列为空，则该工作（worker）线程阻塞在pthread_cond_wait上。若任务（task）队列非空，则取出任务（task）队列的第一个任务，之后立即开锁，并执行任务对应的任务处理函数

     - 建立连接后，当客户端请求到达服务器端时，创建任务（task）并添加到线程池的任务队列尾部，当添加完任务(task)之后调用pthread_cond_signal唤醒阻塞在pthread_cond_wait上的没有具体任务（task）的工作（worker）线程


4. 为了解决粘包、缺包问题而使用的有限状态机的实现？
     - 收包状态： 
     ```C++                   
          - head_init          // 初始状态，准备接收包头
          - head_recving       // 接收包头中
          - body_init          // 包头收完，准备接收包体
          - body_recving       // 接收包体中
     ```
     - 请求结构体（和解析请求的有限状态机关联的部分）：
     ```C++
          - enum state       curstate;
          - char             head[sizeof(request_pkg_head_t)];   // 存放包头信息
          - char*            recv_pointer;                       // 接收数据缓冲区的指针
          - unsigned int     need_recv_len;                      // 还要接收多少数据
     ```

     每个请求结构体初始化为：
     ```C++
	     request->curstate = head_init;
	     request->recv_pointer = request->head;
	     request->need_recv_len = sizeof(request_pkg_head_t);
     ```
     request_control函数内死循环实现：
     ```C++
		int reco = recv(request->fd, request->recv_pointer, request->need_recv_len, 0);
     ```
     
     - 要是请求当前状态为head_init，

          - 要是 request->need_recv_len == reco, 说明包头收完整了，则

               ```C++
			request->curstate = body_init;
			request->recv_pointer = (char*)calloc(body_len, sizeof(char));
			request->need_recv_len = body_len;
               ```

          - 否则，说明包头收到的不完整，则

               ```C++
               request->curstate = head_recving;
			request->recv_pointer = request->recv_pointer + reco;
	          request->need_recv_len = request->need_recv_len - reco;
               ```

     - 要是请求当前状态为head_recving，

          - 要是 request->need_recv_len == reco, 说明包头收完整了，则

               ```C++
			request->curstate = body_init;
			request->recv_pointer = (char*)calloc(body_len, sizeof(char));
			request->need_recv_len = body_len;
               ```

          - 否则，说明包头收到的不完整，则

               ```C++
			request->recv_pointer = request->recv_pointer + reco;
			request->need_recv_len = request->need_recv_len - reco;   
               ```

     - 要是请求当前状态为body_init，
          - 要是 request->need_recv_len == reco，说明包体收完整了，则

               ```C++
               request->curstate = head_init;
	          request->recv_pointer = request->head;
	          request->need_recv_len = sizeof(request_pkg_head_t);
               ```

          - 否则，说明包体收到的不完整，则

               ```C++
               request->curstate = body_recving;
			request->recv_pointer = request->recv_pointer + reco;
		     request->need_recv_len = request->need_recv_len - reco;
               ```

     - 要是请求当前状态为body_recving，
          - 要是 request->need_recv_len == reco，说明包体收完整了，则

               ```C++
               request->curstate = head_init;
	          request->recv_pointer = request->head;
	          request->need_recv_len = sizeof(request_pkg_head_t);
               ```

          - 否则，说明包体收到的不完整，则

               ```C++
               request->recv_pointer = request->recv_pointer + reco;
			request->need_recv_len = request->need_recv_len - reco;
               ```

5. 线程池的同步互斥实现？

     线程同步互斥问题可以使用互斥锁、条件变量、读写锁和信号量。

     主线程负责监听并添加任务（添加回调函数、创建参数）到线程池中，之后工作（worker）线程负责取出任务并执行

     项目采取的同步策略是“互斥锁 + 条件变量"。
     ```C++
     int pthread_mutex_lock(pthread_mutex_t *mptr);
     int pthread_mutex_unlock(pthread_mutex_t *mptr);
     int pthread_cond_wait(pthread_cond_t *cptr, pthread_mutex_t *mptr);
     int pthread_cond_signal(pthread_cond_t *cptr);
     ```

6. 上传文件完整过程？
     - 客户端
          - 使用mmap系统调用映射文件到共享内存区，按块大小（1024字节）封包（包头 + 包体）发送给服务器
     - 服务器端
          - 收全包体后，立即以追加模式写入文件中

7. SIGPIPE

   默认情况下，往一个读端关闭的socket连接中写数据将引发SIGPIPE信号，我们需要在代码中捕获该信号并忽略该信号，因为程序接收到SIGPIPE信号的默认行为是结束进程（假设服务器端往客户端发送文件的过程中，客户端关闭了，SIGPIPE信号的默认行为导致服务器进程关闭）

8. 定时器时做什么的,怎么实现的?

     - 时间轮上有若干个槽位,每个槽位上放置着定时器的双向链表,

     - 主线程定时发送信号,对时间轮的当前指向槽位进行自增,要是当前指向槽位上的某个定时器超时了,则删除该定时器

9. epoll底层实现及其核心参数

     - 执行epoll_create时创建红黑树和就绪链表,执行epoll_ctl时,如果增加的文件描述符在红黑树中存在则立即返回,不存在则添加描述符到红黑树中并向内核注册相应的回调函数.当事件到来时向就绪链表插入描述符及其回调信息

     - epoll有两种工作模式,分别为ET 和 LT,默认为LT,在LT下只要socket的内核接收/发送缓冲区里的数据没有处理完,每次epoll_wait都会返回,而ET模式只在状态发生变化时返回(由可读变成不可读,可写变成不可写,或epoll_mod该事件)