1. 服务器端接收文件的正确性？
     - 问题：

          - 字节流文件无法通过查看内容或者简单的查看文件字节数验证正确性

     - 解决办法：

          - 使用md5sum验证

2. 为了提高并发性而产生的错误？
     - 问题：

          - 为了提高并发性，将任务处理函数放置在互斥锁外执行时，会存在文件传输错误的情况

     - 原因：

          - 当某个工作（worker）线程在执行任务处理函数里的IO操作时，要是该任务绑定的已连接描述符有新的数据达到，会触发其他工作（worker）线程去处理该这些数据，导致两个worker线程同时修改同一个结构体的情况

     - 解决办法:

          - 添加EPOLLONESHOT模式，强制只读一次至读到EAGAIN为止，并epoll_mod该可读事件

3. 线程池的实现？
     - 使用互斥锁保证对线程池的互斥访问，使用条件变量实现同步

     - 初始化线程池，创建工作（worker）线程

     - 各线程入口函数最外层为while循环，获得互斥锁的线程进入线程池，若任务（task）队列为空，则该工作（worker）线程阻塞在pthread_cond_wait上。若任务（task）队列非空，则取出任务（task）队列的第一个任务，之后立即开锁，并执行任务对应的任务处理函数

     - 建立连接后，当客户端请求到达服务器端时，创建任务（task）并添加到线程池的任务队列尾部，当添加完任务(task)之后调用pthread_cond_signal唤醒阻塞在pthread_cond_wait上的没有具体任务（task）的工作（worker）线程


4. 为了解决粘包、缺包问题而使用的有限状态机的实现？
     - 收包状态： 
     ```C++                   
          - head_init          // 初始状态，准备接收包头
          - head_recving       // 接收包头中
          - body_init          // 包头收完，准备接收包体
          - body_recving       // 接收包体中
     ```
     - 请求结构体：
     ```C++
          - enum state       curstate;
          - char             head[sizeof(request_pkg_head_t)];   // 存放包头信息
          - char*            recv_pointer;                       // 接收数据缓冲区的指针
          - unsigned int     need_recv_len;                      // 还要接收多少数据
     ```
5. 线程池的同步互斥实现？
