# FTP 整体设计

**初始化**

- 读取系统配置（监听端口号、线程池线程数）

- 绑定地址与监听

- 创建epoll并添加监听描述符的可读事件（ET)

- 初始化线程池

    - 初始化线程池各参数

    - 创建线程

    - 调用线程入口函数（每个工作（worker）线程循环执行以下几步）：

        - 每个工作（worker）线程进入线程池时都先对线程池加互斥锁

        - 通过条件变量判断是否有待处理任务，如果没任务则阻塞该工作（worker）线程

        - 如果有任务，则取出任务队列中的第一个任务节点

        - 对线程池解锁，之后其他工作（worker）线程可访问该线程池

        - 执行任务对应的操作并删除该任务

        注：这里工作（worker）线程对线程池先解锁在执行任务，是为了提高并发性的考虑，因为在此情况下， 该工作（worker）线程已经获得了某个任务的处理权，其他任务不可能分配给该工作（worker）线程处理。另外，如果将工作（woker）线程对线程池的解锁过程置于执行任务之后，则线程池会被加锁至该工作（worker）线程执行任务结束，整个线程池都会处于锁定状态，任务处理会退化成顺序执行。（任务涉及大量的文件I/O操作）


**任务处理**

- 请求连接 （事件：有连接请求）

    - 接受连接并返回已连接描述符

    - 向epooll中注册已连接描述符的可读事件（ET)

- 响应任务 （事件：请求到达服务器）

    - 将新建的任务加入线程池，任务处理函数为request_control，参数为请求结构（ftp_request_t）

        - 完成ftp_task_t节点初始化，任务队列任务数量queuesize加1

        - 将新任务以头插法的形式加入线程池的任务队列中

        - 调用pthread_cond_signal激活一个处于阻塞状态的线程（只激活一个，避免惊群效应）。在初始化线程池时，线程池里的所有线程因为任务队列为空，所以调用pthread_con_wait后处于阻塞状态。一旦有新任务被加入线程池，条件变量条件（任务队列非空）即可被满足，此时会唤醒某个工作线程来处理该新任务。


## 具体任务处理过程
当某个任务被添加到任务队列中后就会激活一个工作（worker）线程去处理该请求，入口处理函数为request_control。

- 读取用户请求：

    epoll监听已连接描述的可读事件（ET)，使用了一层死循环，直到recv返回-1，并且errno置为EAGAIN。

    - 数据读取错误（recv返回-1，并且errno非EAGAIN）则关闭连接，释放对应数据结构（已连接描述符、请求结构、epoll中删除该已连接描述符)

    - 若errno为EAGAIN：

        - 跳出该死循环（说明本次读取数据已经把已连接描述符的内核接收缓冲区的数据读取完毕）

        - 将该请求于epoll中重新注册（EPOLLONESHOT只触发一次，这里不重新注册，之后都不会获得响应）

        - 结束request_control函数，释放工作（worker）线程控制权
    
    - 否则：

        - 解析请求并填充request_t各变量

        - 返回响应体


## 任务结构定义
使用万能类型的函数指针和万能类型的变量指针是为了程序的可扩展性考虑。
```C++
typedef struct ftp_task {
    void                 (*func)(void*);    // 任务处理函数的函数指针
    void*                arg;               // 任务处理函数的传入参数指针
    struct ftp_task*     next;              // 任务队列（指向下一个任务节点）
}ftp_fask_t;
```

- 任务处理函数的函数指针func

    - 每个任务创建时设置处处理该函数的函数指针func，func为该任务的处理函数

- 任务处理函数的传入参数arg

    - 任务处理函数的传入参数指针指向任务处理函数func需要的参数

- 任务队列下一个任务节点指针next

    - 所有新增的任务以链表形式组织，next指向下一个任务节点


